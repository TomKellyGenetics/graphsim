---
title: "Simulating continuous data based on network graph structures"
author: "Tom Kelly"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Simulating network graph structure in continuous data}
   %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
#knitr::opts_chunk$set(collapse = TRUE, comment = "#>", width = 68)
knitr::opts_chunk$set(fig.cap = "", fig.path = "Plot")
options(width = 68, cli.unicode = FALSE, cli.width = 68)
#par(mai=c(2.82, 2.82, 0.82, 0.82)-0.82)
par(mar=c(7, 10, 4, 2) + 0.1)
par(bty="o")
#captioner::captioner(prefix = "Fig.")
```

# Overview of graphsim

This package is designed to balance user-friendliness (by providing sensible defaults and built-in functions) and flexbility (many options are available to use as needed). It is likely that you will disagree with the parameters that I've used to simulate datasets. That's a valid opinion and there are many options at your disposal to alter parameters to use these functions for your purposes.

If you have issues or feedback, sumbmission to the the GitHub repository are welcome. See the DESCRIPTION and README.md for more details on how to suggest changes to the package.


## Motivations

Pathway and graph structures have a wide array of applications. Here will consider the simulation of (log-normalised) gene expression data from genomics experiments in a biological pathway. If you have another use for this software you are welcome to apply it to your problem, please bear in mind that it was designed with this application in mind however. In principle, normally-distributed continuous data can be generated based on any defined relationships. This uses the graph structure to define a âˆ‘ covariance matrix and generate simulated data by sampling from a multivariate normal distribution.

Crucially, this allows the simulation of negative correlations based on inhibitory or repressive relationships, as commonly occur in biology. A custom plotting function `plot_directed` is provided to visualise these relationships with the "state" parameter. This plotting function has a dedicated vignette on [plotting](plots_directed.Rmd).

For more details on the background of this package, see the [paper](../paper/paper.Rmd) included with the package on GitHub. This vignette provides more detail on the code needed to reproduce the figures in this manuscript.
  
# Getting Started
  
## Install dependencies for Demonstration

The package can be installed as follows. Run the following command to install the current release from CRAN (recommended).

```{r, eval = FALSE}
#install packages required (once per machine)
install.packages("graphsim")
```

Run the following command to install the development version from GitHub (advanced users). This will import the latest changes to the package ahead of releasing updates, behaviour may be unstable.

```{r, eval = FALSE}
#install stable release
remotes::install_github("TomKellyGenetics", ref = "master")
#install development version
remotes::install_github("TomKellyGenetics", ref = "dev")
```

Once the required packages are installed, we must load the packages required to use the package functions with igraph objects and generate plots. Here `igraph` is required to create `igraph` objects and `gplots` is required for plotting heatmaps.

```{r, warning=FALSE, results='hide', message=FALSE}
library("igraph")
library("gplots")
library("graphsim")
```

## Set up simulated graphs

Here we set up a simple graph to demonstrate how connections in the graph structure lead to correlations in the final output. We create a simple pathway of 9 genes with various branches.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
graph_structure_edges <- rbind(c("A", "C"), c("B", "C"), c("C", "D"), c("D", "E"), c("D", "F"), c("F", "G"), c("F", "I"), c("H", "I"))
graph_structure <- graph.edgelist(graph_structure_edges, directed = T)
plot_directed(graph_structure, layout = layout.kamada.kawai)
```

# Generating  simulated expression data from graph

## Minimal example 

A simulated dataset can be generated with a single command. This is all that is required to get started.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, message=FALSE, warning=FALSE}
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0, comm = FALSE, dist = TRUE, absolute = FALSE)
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```

Here we've generated a simulated dataset of 100 samples with gene expression for the genes in the graph shown above. All other functions are called internally and are not needed to compute the final dataset in this heatmap plot. We will show below how these are used to demonstrate what computations are being performed to generate this data from the graph structure given.

Various arguments are supported to alter how the simulated datasets are computed. See the documentation for details.

# How it works step-by-step

Here we show the data generated by for this graph structure. This demonstrates how several of the options available compute the necessary steps.

### Adjacency matrix

The data can be summarised by an "adjacency matrix" where a one (1) is given between a row `i` and column `j` if there is an edge between genes `i` and `j`. Otherise it is a zero (0) for genes that are not connected. For an undirected graph, edges are shown in a symmetical matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
adj_mat <- make_adjmatrix_graph(graph_structure)
heatmap.2(make_adjmatrix_graph(graph_structure), scale = "none", trace = "none", col = colorpanel(3, "grey75", "white", "blue"), colsep = 1:4, rowsep = 1:4)
```

For a directed graph, the edges are not shown from gene (row) `i` and gene (column) `j` 

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
heatmap.2(make_adjmatrix_graph(graph_structure, directed = T), scale = "none", trace = "none", col = colorpanel(3, "grey75", "white", "blue"), colsep = 1:4, rowsep = 1:4)
```

We can compute the common links between each pair of genes. This shows how many genes are connected to both genes `i` and `j`.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
comm_mat <- make_commonlink_graph(graph_structure)
heatmap.2(make_commonlink_graph(graph_structure), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Note that this weights towards genes with a higher vertex degree (as does the Laplacian).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
laplacian_mat <- make_laplacian_graph(graph_structure)
heatmap.2(make_laplacian_graph(graph_structure), scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```

### Distance matrix

To compute the relationships between each gene by "distance" we first compute the shortest paths between each pair of nodes by Dijkstra's algorithm. 

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
shortest.paths(graph_structure)
heatmap.2(shortest.paths(graph_structure), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```
Relative to the "diameter" (length of the longest shortest path between any 2 nodes), we can show which genes are more similar or different based on the graph structure.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
(1+diameter(graph_structure)-shortest.paths(graph_structure))/diameter(graph_structure)
heatmap.2((1+diameter(graph_structure)-shortest.paths(graph_structure))/diameter(graph_structure), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

These relationships are used to create a distance graph relative to the diameter. A relative geometrically decreasing distance is computed as follows. In this case every connected node is weighted in fractions of the diameter.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
make_distance_graph(graph_structure, absolute = F)
heatmap.2(make_distance_graph(graph_structure, absolute = F), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

An arithmetically decreasing distance is computed as follows. In this case every connected node is by the length of their shortest paths relative to the diameter.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
make_distance_graph(graph_structure, absolute = T)
heatmap.2(make_distance_graph(graph_structure, absolute = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

### Sigma matrix

The &Sigma covariance matrix defines the relationships between the simulated gene distributions. Where the diagonal is one (1), the covariance terms are correlations between each gene. Where possible these are derived from the distance relationships described above. In cases where this is not compatible, the nearest "positive definite" symmetric matrix is computed.

These can be computed directly from an adjacency matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#sigma from adj mat
make_sigma_mat_graph(graph_structure, 0.8)
heatmap.2(make_sigma_mat_graph(graph_structure, 0.8), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

A commonlink matrix can also be used to compute a &Sigma matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#sigma from comm mat
make_sigma_mat_graph(graph_structure, 0.8, comm = T)
heatmap.2(make_sigma_mat_graph(graph_structure, 0.8, comm = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

It is recommended to compute the distance relationships and use these. This is supported with the built-in functions. For instance &Sigma from the geometrically computed distances.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# sigma from geometric distance matrix
make_sigma_mat_dist_graph(graph_structure, 0.8, absolute = F)
heatmap.2(make_sigma_mat_dist_graph(graph_structure, 0.8, absolute = F), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

&Sigma can also be computed for arithmetically computed distances.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# sigma from absolute distance matrix
make_sigma_mat_dist_graph(graph_structure, 0.8, absolute = T)
heatmap.2(make_sigma_mat_dist_graph(graph_structure, 0.8, absolute = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

### Simulated expression and observed correlation

Here we generate the final simulated expression dataset. Note that none of the prior steps are required. These are called internalled as needed.

For example, the adjacency matrix is derived to generate the following dataset. Note that the nearest positive definite matrix is required for the &Sigma matrix in this case.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#simulate expression data
#adj mat
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0, comm = F) # unable to generate from adj mat ## fixed with positive definite correction
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we compute a simluated dataset based on common links shared to other nodes.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#comm mat
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0, comm =T) #expression from comm mat
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we use relative distance (relationships are geometrically weighted to the diameter).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# relative dist
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0, comm = F, dist = T, absolute = F)
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we use absolute distance (relationships are arithmetrically weighted to the diameter).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#absolute dist
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0, comm = F, dist = T, absolute = T) # unable to generate from adj mat ## fixed PD
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```


## Summary

In summary, we compute the following expression dataset but on these underlying relationships in the graph structure. Here we use geometrically decreasing correlations between more distant nodes in the network.

```{r simulation_activating_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
# activating graph
state <- rep(1, length(E(graph_structure)))
plot_directed(graph_structure, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_structure, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_structure, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_structure, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

### Inhibiting relationships

Here we simulate the same graph structure with inhibiting edges but passing the `"state"` parameter. This takes one argument for each each to identify which are inhibitory (as documented).

```{r simulation_inhibiting_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
# activating graph
state <- state <- c(1, 1, -1, 1, 1, 1, 1, -1)
plot_directed(graph_structure, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_structure, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_structure, state, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_structure, state, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_structure)), rowsep = 1:length(V(graph_structure)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

# Toy examples

Here we give some toy examples to show how the simulations behave in simple cases. This serves to understand how modules within a larger graph will translate to correlations in the final simulated datasets.

## Diverging branches

```{r simulation_graph_diverging_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
graph_diverging_edges <- rbind(c("A", "B"), c("B", "C"), c("B", "D"))
graph_diverging <- graph.edgelist(graph_diverging_edges, directed = T)

# activating graph
state <- rep(1, length(E(graph_diverging)))
plot_directed(graph_diverging, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_diverging, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_diverging, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_diverging, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

### Inhibiting relationships

Here we simulate the same graph structure with inhibiting edges but passing the `"state"` parameter. This takes one argument for each each to identify which are inhibitory (as documented).

```{r simulation_graph_diverging_inhibiting_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
# activating graph
state <- state <- c(1, 1, -1)
plot_directed(graph_diverging, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_diverging, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_diverging, state, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_diverging, state, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_diverging)), rowsep = 1:length(V(graph_diverging)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

## Converging branches


```{r simulation_graph_converging_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
graph_converging_edges <- rbind(c("C", "E"), c("D", "E"), c("E", "F"))
graph_converging <- graph.edgelist(graph_converging_edges, directed = T)

# activating graph
state <- rep(1, length(E(graph_converging)))
plot_directed(graph_converging, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_converging, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_converging, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_converging, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

### Inhibiting relationships

Here we simulate the same graph structure with inhibiting edges but passing the `"state"` parameter. This takes one argument for each each to identify which are inhibitory (as documented).

```{r simulation_graph_converging_inhibiting_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
# activating graph
state <- state <- c(-1, 1, -1)
plot_directed(graph_converging, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_converging, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_converging, state, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_converging, state, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_converging)), rowsep = 1:length(V(graph_converging)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

## Reconnecting paths


```{r simulation_graph_reconnecting_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
graph_reconnecting_edges <- rbind(c("A", "B"), c("B", "C"), c("B", "D"),c("C", "E"), c("D", "E"), c("E", "F"))
graph_reconnecting <- graph.edgelist(graph_reconnecting_edges, directed = T)

# activating graph
state <- rep(1, length(E(graph_reconnecting)))
plot_directed(graph_reconnecting, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_reconnecting, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_reconnecting, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_reconnecting, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

### Inhibiting relationships

Here we simulate the same graph structure with inhibiting edges but passing the `"state"` parameter. This takes one argument for each each to identify which are inhibitory (as documented).

```{r simulation_graph_reconnecting_inhibiting_hide, fig.show='hold', out.width = '50%', out.height  = '50%', fig.align='center', dpi=36, fig.retina=10, fig.margin = FALSE, fig.ncol = 2, warning=FALSE, message=FALSE}
# activating graph
state <- state <- c(1, 1, -1, -1, 1, 1, 1, 1)
plot_directed(graph_reconnecting, state=state, layout = layout.kamada.kawai,
              cex.node=2, cex.arrow=4, arrow_clip = 0.2)
mtext(text = "(a) Activating pathway structure", side=1, line=3.5, at=0.075, adj=0.5, cex=1.75)
box()
#plot relationship matrix
heatmap.2(make_distance_graph(graph_reconnecting, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = "(b) Relationship matrix", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot sigma matrix
heatmap.2(make_sigma_mat_dist_graph(graph_reconnecting, state, cor = 0.8, absolute = FALSE),
          scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = expression(paste("(c) ", Sigma, " matrix")), side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#simulated data
expr <- generate_expression(100, graph_reconnecting, state, cor = 0.8, mean = 0,
                            comm = FALSE, dist =TRUE, absolute = FALSE, state = state)
#plot simulated correlations
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "blue", "white", "red"),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)))
mtext(text = "(d) Simulated correlation", side=1, line=3.5, at=0, adj=0.5, cex=1.75)
#plot simulated expression data
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50),
          colsep = 1:length(V(graph_reconnecting)), rowsep = 1:length(V(graph_reconnecting)), labCol = "")
mtext(text = "samples", side=1, line=1.5, at=0.2, adj=0.5, cex=1.5)
mtext(text = "genes", side=4, line=1, at=-0.4, adj=0.5, cex=1.5)
mtext(text = "(e) Simulated expression data (log scale)", side=1, line=3.5, at=0, adj=0.5, cex=1.75)

```

# Empirical examples