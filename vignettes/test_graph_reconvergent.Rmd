---
title: "Simulating reconvergent graph structure in continuous data"
author: "Tom Kelly"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Simulating reconvergent graph structure in continuous data}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---
  
  # Getting Started
  
  ## Install dependencies for Demonstration
  
  First we must load the packages required to use the pacakge functions with igraph objects and generate plots.

```{r, message=F, warning=F}
library("igraph")
library("gplots")
library("graphsim")
```

## Set up simulated graphs

Here we set up a simple graph to demonstrate how connections in the graph structure lead to correlations in the final output. We create a simple pathway of 6 genes with 2 downstream genes activated by an upstream pathway which in turn activate a downstream pathway.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
graph_test3_edges <- rbind(c("A", "B"), c("B", "C"), c("B", "D"),c("C", "E"), c("D", "E"), c("E", "F"))
graph_test3 <- graph.edgelist(graph_test3_edges, directed = T)
plot_directed(graph_test3, layout = layout.kamada.kawai)
```

# Generating  simulated expression data from graph

## Minimal example 

A simulated dataset can be generated with a single command. This is all that is required to get started.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
expr <- generate_expression(100, graph_test3, cor = 0.8, mean = 0, comm = F, dist = T, absolute = F)
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```

Various arguments are supported to alter how the simulated datasets are computed. 

# How it works step-by-step

Here we show the data generated by for this graph structure. This demonstrates how several of the options available compute the necessary steps.

## Adjacency matrix

The data can be summarised by an "adjacency matrix" where a one (1) is given between a row `i` and column `j` if there is an edge between genes `i` and `j`. Otherise it is a zero (0) for genes that are not connected. For an undirected graph, edges are shown in a symmetical matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
adj_mat <- make_adjmatrix_graph(graph_test3)
heatmap.2(make_adjmatrix_graph(graph_test3), scale = "none", trace = "none", col = colorpanel(3, "grey75", "white", "blue"), colsep = 1:4, rowsep = 1:4)
```

For a directed graph, the edges are not shown from gene (row) `i` and gene (column) `j` 

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
heatmap.2(make_adjmatrix_graph(graph_test3, directed = T), scale = "none", trace = "none", col = colorpanel(3, "grey75", "white", "blue"), colsep = 1:4, rowsep = 1:4)
```

We can compute the common links between each pair of genes. This shows how many genes are connected to both genes `i` and `j`.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
comm_mat <- make_commonlink_graph(graph_test3)
heatmap.2(make_commonlink_graph(graph_test3), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Note that this weights towards genes with a higher vertex degree (as does the Laplacian).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
laplacian_mat <- make_laplacian_graph(graph_test3)
heatmap.2(make_laplacian_graph(graph_test3), scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```

## Distance matrix

To compute the relationships between each gene by "distance" we first compute the shortest paths between each pair of nodes by Dijkstra's algorithm. 

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
shortest.paths(graph_test3)
heatmap.2(shortest.paths(graph_test3), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```
Relative to the "diameter" (length of the longest shortest path between any 2 nodes), we can show which genes are more similar or different based on the graph structure.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
(1+diameter(graph_test3)-shortest.paths(graph_test3))/diameter(graph_test3)
heatmap.2((1+diameter(graph_test3)-shortest.paths(graph_test3))/diameter(graph_test3), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

These relationships are used to create a distance graph relative to the diameter. A relative geometrically decreasing distance is computed as follows. In this case every connected node is weighted in fractions of the diameter.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
make_distance_graph(graph_test3, absolute = F)
heatmap.2(make_distance_graph(graph_test3, absolute = F), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

An arithmetically decreasing distance is computed as follows. In this case every connected node is by the length of their shortest paths relative to the diameter.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
make_distance_graph(graph_test3, absolute = T)
heatmap.2(make_distance_graph(graph_test3, absolute = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

## Sigma matrix

The &Sigma covariance matrix defines the relationships between the simulated gene distributions. Where the diagonal is one (1), the covariance terms are correlations between each gene. Where possible these are derived from the distance relationships described above. In cases where this is not compatible, the nearest "positive definite" symmetric matrix is computed.

These can be computed directly from an adjacency matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#sigma from adj mat
make_sigma_mat_graph(graph_test3, 0.8)
heatmap.2(make_sigma_mat_graph(graph_test3, 0.8), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

A commonlink matrix can also be used to compute a &Sigma matrix.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#sigma from comm mat
make_sigma_mat_graph(graph_test3, 0.8, comm = T)
heatmap.2(make_sigma_mat_graph(graph_test3, 0.8, comm = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

It is recommended to compute the distance relationships and use these. This is supported with the built-in functions. For instance &Sigma from the geometrically computed distances.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# sigma from geometric distance matrix
make_sigma_mat_dist_graph(graph_test3, 0.8, absolute = F)
heatmap.2(make_sigma_mat_dist_graph(graph_test3, 0.8, absolute = F), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

&Sigma can also be computed for arithmetically computed distances.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# sigma from absolute distance matrix
make_sigma_mat_dist_graph(graph_test3, 0.8, absolute = T)
heatmap.2(make_sigma_mat_dist_graph(graph_test3, 0.8, absolute = T), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

# Simulated expression and observed correlation

Here we generate the final simulated expression dataset. Note that none of the prior steps are required. These are called internalled as needed.

For example, the adjacency matrix is derived to generate the following dataset. Note that the nearest positive definite matrix is required for the &Sigma matrix in this case.


```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#simulate expression data
#adj mat
expr <- generate_expression(100, graph_test3, cor = 0.8, mean = 0, comm = F) # unable to generate from adj mat ## fixed with positive definite correction
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we compute a simluated dataset based on common links shared to other nodes.

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#comm mat
expr <- generate_expression(100, graph_test3, cor = 0.8, mean = 0, comm =T) #expression from comm mat
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we use relative distance (relationships are geometrically weighted to the diameter).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
# relative dist
expr <- generate_expression(100, graph_test3, cor = 0.8, mean = 0, comm = F, dist = T, absolute = F)
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = colorpanel(50, "grey75", "red"), colsep = 1:4, rowsep = 1:4)
```

Here we use absolute distance (relationships are arithmetrically weighted to the diameter).

```{r, out.width = '50%', out.height  = '50%', fig.align='center', dpi=36}
#absolute dist
expr <- generate_expression(100, graph_test3, cor = 0.8, mean = 0, comm = F, dist = T, absolute = T) # unable to generate from adj mat ## fixed PD
heatmap.2(expr, scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
heatmap.2(cor(t(expr)), scale = "none", trace = "none", col = bluered(50), colsep = 1:4, rowsep = 1:4)
```
